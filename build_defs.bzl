"""Build definitions for qt 6."""

load("@qt-bazel//:qt_tools.bzl", "moc_gen")

def _copy_or_empty_list(vals):
    # Starlark has no list copy() function.
    return vals + [] if vals else []

def qt6_library(
        name = "",
        deps = None,
        moc_hdrs = None,
        moc_textual_hdrs = None,
        moc_srcs = None,
        uic_srcs = None,
        defines = None,
        linkopts = None,
        copts = None,
        includes = None,
        testonly = 0,
        hdrs = None,
        textual_hdrs = None,
        srcs = None,
        qt_gui_platform = "native",
        alwayslink = 0,
        provide_bare_qt_keywords = True,
        compatible_with = [],
        linkstatic = True,
        **kwargs):
    """Builds a library which includes sources generated by Qt's moc and uic tools.

    Definition of qt_library rule type.

    This rule generate all the subrules necessary to handle QT files : it runs the
    uic compiler on the .ui files listed in 'uic_srcs' to generate ui_foo.h files,
    and runs 'moc' on the .h files listed in 'moc_hdrs' and .cc/.cpp files in
    'moc_srcs' to generate moc_[h|cc]_foo.cpp source files.
    Usage example:

    load("@qt-bazel//:build_defs.bzl", "qt6_library")

    qt6_library(
        name = "my_libname",
        hdrs = ["myplainclass.h"],
        srcs = ["myplainclass.cpp"],
        moc_hdrs = [
            "myheadertopreprocess.h",
        ],
        moc_srcs = [
            "myclasstopreprocess.cpp",
            "myotherclasstopreprocess.cpp",
        ],
        uic_srcs = [
            "myuifiletoprocess.ui",
        ],
    )

    Args:
      name: The name of the library.
      deps: passed to cc_library; Qt will be added automatically.
      moc_hdrs: list of header files to pass through moc tool and add as source.
      moc_textual_hdrs: list of header files to pass through moc tool and add as textual headers.
      moc_srcs: list of source files to pass through moc tool and add as textual headers.
      uic_srcs: list of .ui files to pass through uic tool. Generated files will follow the format
        ui_foo.h (or path/to/ui_foo.h for files in directories).
      defines: passed to cc_library.
      linkopts: passed to cc_library.
      copts: passed to cc_library.
      includes: passed to cc_library.
      testonly: passed to cc_library.
      hdrs: non-Qt header files; passed to cc_library.
      textual_hdrs: non-Qt textual header files; passed to cc_library.
      srcs: non-Qt source files; passed to cc_library.
      qt_gui_platform: specifies which windowing system the GUI libraries should be built for.
        Currently supported options are: "native" for X11 + hardware-accelerated OpenGL, "headless"
        for headless systems such as forge/borg + software-based OpenGL
      alwayslink: passed to cc_library.
      provide_bare_qt_keywords: bool, if false, then pass -DQT_NO_KEYWORDS as a compiler flag. This
        prevents the keywords (signals, slots, emit) from being defined, and is useful when non-Qt
        code happens to have identifiers that collide with these keywords. In order to use this
        target, all Qt code that uses signals/slots/emit must first be migrated to use
        Q_SIGNALS/Q_SLOTS/Q_EMIT. For more information,
        see:https://doc.qt.io/qt-5/signalsandslots.html#using-qt-with-3rd-party-signals-and-slots
      compatible_with: passed to cc_library and moc targets.
      linkstatic: passed to cc_library.
      **kwargs: passed to cc_library.
    """

    # Copy the args so we don't end up modifying their original values. This
    # allows headless and native libraries to reuse using the same inputs.
    deps = _copy_or_empty_list(deps)
    moc_hdrs = _copy_or_empty_list(moc_hdrs)
    moc_textual_hdrs = _copy_or_empty_list(moc_textual_hdrs)
    moc_srcs = _copy_or_empty_list(moc_srcs)
    uic_srcs = _copy_or_empty_list(uic_srcs)
    defines = _copy_or_empty_list(defines)
    linkopts = _copy_or_empty_list(linkopts)
    copts = _copy_or_empty_list(copts)
    includes = _copy_or_empty_list(includes)
    hdrs = _copy_or_empty_list(hdrs)
    textual_hdrs = _copy_or_empty_list(textual_hdrs)
    srcs = _copy_or_empty_list(srcs)

    if not provide_bare_qt_keywords and "QT_NO_KEYWORDS" not in defines:
        defines.append("QT_NO_KEYWORDS")

    library_hdrs = hdrs

    uic_binary = "@qt-bazel//qt_source:uic"

    uic_gen_deps = []
    for uic_src in uic_srcs:
        # Handle the compilation of .ui files
        # We need to generate the source code (.qt.cc,.qt.h) using uic.

        (uic_src_dir, sep, uic_src_file) = uic_src.rpartition("/")
        base_name = uic_src_file[0:-3]
        uic_out_hdr = uic_src_dir + sep + "ui_" + base_name + ".h"
        lib_name = (uic_src_dir + sep).replace("/", "_") + "ui_" + base_name

        # Pass the -n flag to uic to prevent it from automatically generating
        # #include directives for headers in the current directory. This means
        # that if your .ui file depends on a custom widget, the C++ code that
        # includes the generates ui_*.h header file needs to include the header
        # for the custom widget first.
        cmd = "$(location %s) $(location %s) -o $(location %s) -n" % (
            uic_binary,
            uic_src,
            uic_out_hdr,
        )
        native.genrule(
            name = lib_name,
            srcs = [uic_src],
            outs = [uic_out_hdr],
            tools = [uic_binary],
            cmd = cmd,
        )

        # According to the cc_library rule doc, "The default include path
        # doesn't include generated files. If you need to #include a
        # generated header file, list it in the srcs."
        srcs.append(uic_out_hdr)
        uic_gen_deps.append(":" + lib_name)

    moc_genrules = []
    for moc_src in moc_srcs:
        (moc_src_dir, sep, moc_src_file) = moc_src.rpartition("/")

        if moc_src.endswith(".cc"):
            base_name = moc_src_file[0:-3]
        elif moc_src.endswith(".cpp"):
            base_name = moc_src_file[0:-4]
        else:
            fail("Unsupported extension for %s" % moc_src, "moc_srcs")

        moc_file = (
            moc_src_dir +
            sep +
            "moc_cc_" +
            qt_gui_platform +
            "_" +
            base_name +
            ".cc"
        )
        moc_genrules.append({
            "name": (
                (moc_src_dir + sep).replace("/", "_") +
                "moc_cc_" +
                qt_gui_platform +
                "_" +
                base_name
            ),
            "source": moc_src,
            "output": moc_file,
            "input": moc_src,
        })
        srcs.append(moc_src)
        textual_hdrs.append(moc_file)

    for moc_hdr in moc_hdrs:
        (moc_hdr_dir, sep, moc_hdr_file) = moc_hdr.rpartition("/")

        if moc_hdr.endswith(".h"):
            base_name = moc_hdr_file[0:-2]
        elif moc_hdr.endswith(".hh"):
            base_name = moc_hdr_file[0:-3]
        elif moc_hdr.endswith(".hpp"):
            base_name = moc_hdr_file[0:-4]
        else:
            fail("Unsupported extension for %s" % moc_hdr, "moc_hdrs")
        moc_file = (
            moc_hdr_dir + sep + "moc_h_" + qt_gui_platform + "_" + base_name + ".cc"
        )
        moc_genrules.append({
            "name": (
                (moc_hdr_dir + sep).replace("/", "_") +
                "moc_h_" +
                qt_gui_platform +
                "_" +
                base_name
            ),
            "source": moc_hdr,
            "output": moc_file,
            "input": moc_hdr,
        })

        # Don't add moc_hdr to hdrs if it's already there
        if moc_hdr not in hdrs:
            hdrs += [moc_hdr]

        srcs.append(moc_file)

    for moc_textual_hdr in moc_textual_hdrs:
        (moc_textual_hdr, sep, moc_hdr_file) = moc_textual_hdr.rpartition("/")

        if moc_textual_hdr.endswith(".h"):
            base_name = moc_hdr_file[0:-2]
        elif moc_textual_hdr.endswith(".hh"):
            base_name = moc_hdr_file[0:-3]
        elif moc_textual_hdr.endswith(".hpp"):
            base_name = moc_hdr_file[0:-4]
        else:
            fail("Unsupported extension for %s" % moc_textual_hdr, "moc_textual_hdrs")
        moc_file = (
            moc_textual_hdr + sep + "moc_h_" + qt_gui_platform + "_" + base_name + ".cc"
        )
        moc_genrules.append({
            "name": (
                (moc_textual_hdr + sep).replace("/", "_") +
                "moc_h_" +
                qt_gui_platform +
                "_" +
                base_name
            ),
            "source": moc_textual_hdr,
            "output": moc_file,
            "input": moc_textual_hdr,
        })

        # Don't add moc_textual_hdr to textual_hdrs if it's already there
        if moc_textual_hdr not in textual_hdrs:
            textual_hdrs.append(moc_textual_hdr)

        textual_hdrs.append(moc_file)

    deps.append("@qt-bazel//qt_source:core")
    deps.append("@qt-bazel//qt_source:widgets")
    deps.append("@qt-bazel//qt_source:charts")
    deps.append("@qt-bazel//qt_source:gui")
    deps.append("@qt-bazel//qt_source:xcb_integration_plugin")

    # Add a header-only cc_library to pass in include flags, hdrs, and defines
    # to the moc call.  This allows the moc_gen Skylark rule to pass the
    # appropriate hdrs, includes, and defines from the outer qt6_library
    # without a bunch of trickery, since from the perspective of the moc_gen
    # internals this is just another dependency.
    internal_deps_lib_name = name + "_internal_deps"
    native.cc_library(
        name = internal_deps_lib_name,
        includes = includes,
        textual_hdrs = library_hdrs,
        defines = defines,
        compatible_with = compatible_with,
    )

    moc_deps = deps + [internal_deps_lib_name]

    for moc_genrule in moc_genrules:
        lib_name = moc_genrule["name"]

        moc_gen(
            name = lib_name,
            src = moc_genrule["source"],
            out = moc_genrule["output"],
            deps = moc_deps,
            testonly = testonly,
            compatible_with = compatible_with,
        )

    native.cc_library(
        name = name,
        defines = defines,
        srcs = srcs,
        hdrs = hdrs,
        textual_hdrs = textual_hdrs,
        copts = copts,
        linkopts = linkopts,
        deps = deps + uic_gen_deps,
        testonly = testonly,
        includes = includes,
        alwayslink = alwayslink,
        compatible_with = compatible_with,
        linkstatic = linkstatic,
        **kwargs
    )

def qt6_resource_library(
        name = "",
        srcs = None,
        qrc_srcs = None,
        data_srcs = None,
        out = None,
        root = None,
        external_init_name = None,
        alwayslink = 1,
        qt_gui_platform = "nogl",
        **kwargs):
    """Creates a Qt resources library.

    Note:
      Either srcs can be specified or both qrc_srcs and data_srcs can be specified.

    Args:
      name: A string, the name of the target library.
      srcs: A list of strings, specifies all resource files (data and qrc)
      qrc_srcs: A list of strings, specifies the .qrc files to package.
      data_srcs: A list of strings, specifies the resource files referenced by the .qrc files.
      out: A string, specifies the output file of the generation tool. If not provided, appends
        ".cc" to the library name.
      root: A string, if provided, prefixes the resource access with the provided string.
      external_init_name: A string, if provided generates an external initialization function using
        the provided name.
      alwayslink: Passed onto the qt6_library rule; if set to False/0, then a Q_INIT_RESOURCE
        statement will be needed to load the resources at runtime;if set to True/1, then no such
        statement is required.
      qt_gui_platform: specifies which windowing system the GUI libraries should be built for.
        Currently supported options are: "native" for X11 + hardware-accelerated OpenGL, "headless"
        for headless systems such as forge/borg + software-based OpenGL
      **kwargs: Forwards other arguments onto the generated build rules.
    """

    # Validate arguments, and fill in dynamic defaults.
    if not name:
        fail("Missing name")

    if srcs and not (data_srcs or qrc_srcs):
        qrc_srcs = [src for src in srcs if src.lower().endswith(".qrc")]
        data_srcs = [src for src in srcs if src not in qrc_srcs]
    elif data_srcs and qrc_srcs and not srcs:
        srcs = data_srcs + qrc_srcs
    else:
        fail(
            "Either (exclusively) srcs or both data_srcs and qrc_srcs must be specified",
        )

    if not out:
        out = "%s.cc" % name

    # Creates the shell command to execute.
    gen_tool = "@qt-bazel//qt_source:rcc"

    gen_args = ["'$(location %s)'" % gen_tool]
    if root:
        gen_args.append("--root='%s'" % root)
    if external_init_name:
        gen_args.append("--name='%s'" % external_init_name)

    gen_args.append("--output='$(location %s)'" % out)
    gen_args.extend([("'$(location %s)'" % src) for src in qrc_srcs])

    gen_cmd = " ".join(gen_args)
    gen_name = name + "_rccgen"

    # Generates the cc file, by executing rcc.
    native.genrule(
        name = gen_name,
        srcs = srcs,
        outs = [out],
        cmd = gen_cmd,
        tools = [gen_tool],
        **kwargs
    )

    # Generates the library.
    native.cc_library(
        name = name,
        srcs = [out],
        alwayslink = alwayslink,
        deps = [
            "@qt-bazel//qt_source:core",
            "@qt-bazel//qt_source:gui",
            "@qt-bazel//qt_source:widgets",
            "@qt-bazel//qt_source:charts",
        ],
        **kwargs
    )
